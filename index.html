<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text Grid</title>
<style>
  body {
    margin: 0;
    padding: 20px;
    background: #faf8f5;
    color: #2a2a2a;
    font-family: monospace;
  }
  
  .controls {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }
  
  input[type="number"], input[type="text"] {
    width: 60px;
    padding: 5px;
    border: 1px solid #ddd;
    background: #fff;
  }
  
  input[type="text"] {
    width: 120px;
  }
  
  button {
    padding: 6px 12px;
    border: 1px solid #ddd;
    background: #ff8c42;
    color: #faf8f5;
    cursor: pointer;
    border-radius: 3px;
  }
  
  button:hover {
    background: #ff7028;
  }
  
  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  
  .main-container {
    display: flex;
    gap: 20px;
  }
  
  #grid {
    display: inline-grid;
    gap: 1px;
    background: #ddd;
    border: 2px solid #2a2a2a;
    user-select: none;
  }
  
  .tile {
    width: 14px;
    height: 20px;
    background: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: text;
    font-size: 14px;
    position: relative;
  }
  
  .tile.focused {
    outline: 2px solid #00d9ff;
    z-index: 1;
  }
  
  .tile.dragging {
    opacity: 0.5;
  }
  
  .saved-states {
    min-width: 250px;
    max-width: 350px;
  }
  
  .saved-states h3 {
    margin-top: 0;
    font-size: 14px;
  }
  
  .tabs-container {
    display: flex;
    gap: 5px;
    margin-bottom: 10px;
    flex-wrap: wrap;
  }
  
  .tab {
    padding: 6px 10px;
    background: #ddd;
    border: 1px solid #bbb;
    cursor: pointer;
    border-radius: 3px 3px 0 0;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  
  .tab.active {
    background: #00d9ff;
    color: #faf8f5;
    border-color: #00d9ff;
  }
  
  .tab-close {
    background: none;
    border: none;
    color: inherit;
    padding: 0;
    font-size: 14px;
    cursor: pointer;
    margin: 0;
  }
  
  .tab-close:hover {
    color: #ff6b6b;
  }
  
  .new-tab-btn {
    padding: 6px 10px;
    font-size: 12px;
    background: #6ecf8f;
  }
  
  .new-tab-btn:hover {
    background: #5bbf7f;
  }
  
  .state-item {
    border: 2px solid #ddd;
    padding: 8px;
    margin-bottom: 10px;
    background: #fff;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .state-item:hover {
    border-color: #ff8c42;
  }
  
  .state-item canvas {
    width: 100%;
    height: auto;
    image-rendering: pixelated;
    border: 1px solid #ddd;
    margin-bottom: 5px;
  }
  
  .state-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
  }
  
  .state-delete {
    background: #ff6b6b;
    padding: 2px 6px;
    font-size: 10px;
  }
  
  .state-delete:hover {
    background: #ff5252;
  }
</style>
</head>
<body>

<div class="controls">
  <label>Rows: <input type="number" id="rows" value="30" min="1"></label>
  <label>Cols: <input type="number" id="cols" value="50" min="1"></label>
  <button onclick="createGrid()">Resize</button>
  <button onclick="undo()" id="undoBtn" disabled>Undo</button>
  <button onclick="saveGridState()">Save State</button>
  <button onclick="copyText()">Copy</button>
  <button onclick="clearGrid()">Clear</button>
</div>

<div class="main-container">
  <div id="grid"></div>
  
  <div class="saved-states">
    <h3>Branches</h3>
    <div class="tabs-container" id="tabsContainer"></div>
    <div id="statesList"></div>
  </div>
</div>

<script>
let rows = 30;
let cols = 50;
let focusedRow = 0;
let focusedCol = 0;
let tiles = [];
let history = [];
let maxHistory = 50;
let branches = {};
let activeBranch = 'main';

// Load from localStorage
function loadFromStorage() {
  const saved = localStorage.getItem('textGrid');
  if (saved) {
    const data = JSON.parse(saved);
    branches = data.branches || { main: [] };
    activeBranch = data.activeBranch || 'main';
    
    if (data.currentGrid) {
      rows = data.currentGrid.rows;
      cols = data.currentGrid.cols;
      document.getElementById('rows').value = rows;
      document.getElementById('cols').value = cols;
      
      createGrid();
      
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          tiles[r][c].textContent = data.currentGrid.grid[r][c];
        }
      }
      focusTile(0, 0);
    }
  } else {
    branches = { main: [] };
  }
  renderTabs();
  renderSavedStates();
}

// Save to localStorage
function saveToStorage() {
  const currentGrid = [];
  for (let r = 0; r < rows; r++) {
    currentGrid[r] = [];
    for (let c = 0; c < cols; c++) {
      currentGrid[r][c] = tiles[r][c].textContent;
    }
  }
  
  const data = {
    branches: branches,
    activeBranch: activeBranch,
    currentGrid: {
      grid: currentGrid,
      rows: rows,
      cols: cols
    }
  };
  
  localStorage.setItem('textGrid', JSON.stringify(data));
}

function saveState() {
  const state = [];
  for (let r = 0; r < rows; r++) {
    state[r] = [];
    for (let c = 0; c < cols; c++) {
      state[r][c] = tiles[r][c].textContent;
    }
  }
  history.push({ grid: state, row: focusedRow, col: focusedCol });
  if (history.length > maxHistory) history.shift();
  updateUndoButton();
}

function undo() {
  if (history.length === 0) return;
  const state = history.pop();
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      tiles[r][c].textContent = state.grid[r][c];
    }
  }
  focusTile(state.row, state.col);
  updateUndoButton();
  saveToStorage();
}

function updateUndoButton() {
  document.getElementById('undoBtn').disabled = history.length === 0;
}

function createNewBranch() {
  const name = prompt('Branch name:', `branch-${Object.keys(branches).length + 1}`);
  if (!name || name.trim() === '') return;
  
  branches[name] = [];
  activeBranch = name;
  renderTabs();
  renderSavedStates();
  saveToStorage();
}

function switchBranch(name) {
  activeBranch = name;
  renderTabs();
  renderSavedStates();
  saveToStorage();
}

function deleteBranch(name) {
  if (name === 'main') {
    alert('Cannot delete main branch');
    return;
  }
  
  if (confirm(`Delete branch "${name}"?`)) {
    delete branches[name];
    if (activeBranch === name) {
      activeBranch = 'main';
    }
    renderTabs();
    renderSavedStates();
    saveToStorage();
  }
}

function renderTabs() {
  const container = document.getElementById('tabsContainer');
  container.innerHTML = '';
  
  Object.keys(branches).forEach(name => {
    const tab = document.createElement('div');
    tab.className = 'tab' + (name === activeBranch ? ' active' : '');
    
    const label = document.createElement('span');
    label.textContent = name;
    tab.appendChild(label);
    
    if (name !== 'main') {
      const closeBtn = document.createElement('button');
      closeBtn.className = 'tab-close';
      closeBtn.textContent = 'Ã—';
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        deleteBranch(name);
      };
      tab.appendChild(closeBtn);
    }
    
    tab.onclick = () => switchBranch(name);
    container.appendChild(tab);
  });
  
  const newBtn = document.createElement('button');
  newBtn.className = 'new-tab-btn';
  newBtn.textContent = '+';
  newBtn.onclick = createNewBranch;
  container.appendChild(newBtn);
}

function saveGridState() {
  const state = [];
  for (let r = 0; r < rows; r++) {
    state[r] = [];
    for (let c = 0; c < cols; c++) {
      state[r][c] = tiles[r][c].textContent;
    }
  }
  
  const timestamp = new Date().toLocaleString();
  branches[activeBranch].push({
    grid: state,
    rows: rows,
    cols: cols,
    timestamp: timestamp
  });
  
  renderSavedStates();
  saveToStorage();
}

function loadGridState(index) {
  const state = branches[activeBranch][index];
  
  if (state.rows !== rows || state.cols !== cols) {
    document.getElementById('rows').value = state.rows;
    document.getElementById('cols').value = state.cols;
    createGrid();
  }
  
  saveState();
  
  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      tiles[r][c].textContent = state.grid[r][c];
    }
  }
  
  focusTile(0, 0);
  saveToStorage();
}

function deleteGridState(index) {
  branches[activeBranch].splice(index, 1);
  renderSavedStates();
  saveToStorage();
}

function renderSavedStates() {
  const container = document.getElementById('statesList');
  container.innerHTML = '';
  
  const states = branches[activeBranch] || [];
  
  states.forEach((state, index) => {
    const item = document.createElement('div');
    item.className = 'state-item';
    
    const canvas = document.createElement('canvas');
    const previewWidth = 250;
    const previewHeight = Math.floor(previewWidth * (state.rows / state.cols));
    canvas.width = state.cols;
    canvas.height = state.rows;
    canvas.style.width = previewWidth + 'px';
    canvas.style.height = previewHeight + 'px';
    
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, state.cols, state.rows);
    ctx.fillStyle = '#2a2a2a';
    ctx.font = '1px monospace';
    
    for (let r = 0; r < state.rows; r++) {
      for (let c = 0; c < state.cols; c++) {
        const char = state.grid[r][c];
        if (char !== ' ') {
          ctx.fillText(char, c, r + 0.8);
        }
      }
    }
    
    const info = document.createElement('div');
    info.className = 'state-info';
    info.innerHTML = `
      <span>${state.timestamp}</span>
      <button class="state-delete" onclick="event.stopPropagation(); deleteGridState(${index})">Delete</button>
    `;
    
    item.appendChild(canvas);
    item.appendChild(info);
    item.onclick = () => loadGridState(index);
    
    container.appendChild(item);
  });
}

function createGrid() {
  rows = parseInt(document.getElementById('rows').value);
  cols = parseInt(document.getElementById('cols').value);
  
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  grid.style.gridTemplateColumns = `repeat(${cols}, 14px)`;
  tiles = [];
  history = [];
  updateUndoButton();
  
  for (let r = 0; r < rows; r++) {
    tiles[r] = [];
    for (let c = 0; c < cols; c++) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.textContent = ' ';
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.draggable = true;
      
      tile.addEventListener('click', () => focusTile(r, c));
      tile.addEventListener('dblclick', () => pasteAtTile(r, c));
      tile.addEventListener('dragstart', handleDragStart);
      tile.addEventListener('dragover', handleDragOver);
      tile.addEventListener('drop', handleDrop);
      
      grid.appendChild(tile);
      tiles[r][c] = tile;
    }
  }
  
  focusTile(0, 0);
}

function focusTile(r, c) {
  document.querySelectorAll('.tile').forEach(t => t.classList.remove('focused'));
  if (tiles[r] && tiles[r][c]) {
    tiles[r][c].classList.add('focused');
    focusedRow = r;
    focusedCol = c;
  }
}

function advanceCursor() {
  focusedCol++;
  if (focusedCol >= cols) {
    focusedCol = 0;
    focusedRow++;
    if (focusedRow >= rows) {
      focusedRow = rows - 1;
      focusedCol = cols - 1;
    }
  }
  focusTile(focusedRow, focusedCol);
}

function pasteAtTile(r, c) {
  navigator.clipboard.readText().then(text => {
    if (!text) return;
    
    saveState();
    focusTile(r, c);
    
    for (let char of text) {
      if (focusedRow >= rows) break;
      
      if (char === '\n') {
        focusedCol = 0;
        focusedRow++;
      } else {
        tiles[focusedRow][focusedCol].textContent = char;
        focusedCol++;
        
        if (focusedCol >= cols) {
          focusedCol = 0;
          focusedRow++;
        }
      }
    }
    
    focusTile(focusedRow, focusedCol);
    saveToStorage();
  });
}

function handleDragStart(e) {
  saveState();
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', e.target.textContent);
  e.dataTransfer.setData('row', e.target.dataset.row);
  e.dataTransfer.setData('col', e.target.dataset.col);
  e.target.classList.add('dragging');
}

function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
}

function handleDrop(e) {
  e.preventDefault();
  const char = e.dataTransfer.getData('text/plain');
  const srcRow = e.dataTransfer.getData('row');
  const srcCol = e.dataTransfer.getData('col');
  
  document.querySelectorAll('.dragging').forEach(t => t.classList.remove('dragging'));
  
  const destRow = parseInt(e.target.dataset.row);
  const destCol = parseInt(e.target.dataset.col);
  
  const destChar = e.target.textContent;
  e.target.textContent = char;
  if (srcRow && srcCol) {
    tiles[srcRow][srcCol].textContent = destChar;
  }
  
  focusTile(destRow, destCol);
  saveToStorage();
}

function copyText() {
  let text = '';
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      text += tiles[r][c].textContent;
    }
    if (r < rows - 1) text += '\n';
  }
  navigator.clipboard.writeText(text);
}

function clearGrid() {
  saveState();
  tiles.forEach(row => row.forEach(tile => tile.textContent = ' '));
  focusTile(0, 0);
  saveToStorage();
}

document.addEventListener('paste', (e) => {
  e.preventDefault();
  const text = e.clipboardData.getData('text/plain');
  if (!text) return;
  
  saveState();
  
  for (let char of text) {
    if (focusedRow >= rows) break;
    
    if (char === '\n') {
      focusedCol = 0;
      focusedRow++;
    } else {
      tiles[focusedRow][focusedCol].textContent = char;
      focusedCol++;
      
      if (focusedCol >= cols) {
        focusedCol = 0;
        focusedRow++;
      }
    }
  }
  
  focusTile(focusedRow, focusedCol);
  saveToStorage();
});

document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    undo();
    e.preventDefault();
  }
  else if (e.key === 'ArrowUp' && focusedRow > 0) {
    focusTile(focusedRow - 1, focusedCol);
    e.preventDefault();
  } else if (e.key === 'ArrowDown' && focusedRow < rows - 1) {
    focusTile(focusedRow + 1, focusedCol);
    e.preventDefault();
  } else if (e.key === 'ArrowLeft' && focusedCol > 0) {
    focusTile(focusedRow, focusedCol - 1);
    e.preventDefault();
  } else if (e.key === 'ArrowRight' && focusedCol < cols - 1) {
    focusTile(focusedRow, focusedCol + 1);
    e.preventDefault();
  }
  else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
    saveState();
    tiles[focusedRow][focusedCol].textContent = e.key;
    advanceCursor();
    saveToStorage();
    e.preventDefault();
  }
  else if (e.key === 'Backspace') {
    saveState();
    tiles[focusedRow][focusedCol].textContent = ' ';
    if (focusedCol > 0) {
      focusTile(focusedRow, focusedCol - 1);
    } else if (focusedRow > 0) {
      focusTile(focusedRow - 1, cols - 1);
    }
    saveToStorage();
    e.preventDefault();
  }
});

// Auto-save on any change
setInterval(saveToStorage, 2000);

// Initialize
loadFromStorage();
if (tiles.length === 0) createGrid();
</script>

</body>
</html>
